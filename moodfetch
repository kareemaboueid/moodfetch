#!/usr/bin/env bash
# vim: noai:ts=4:sw=4:expandtab
# shellcheck source=/dev/null
# shellcheck disable=2009

# Resolve script directory:
# - If installed via `make install`, prefer /usr/local/share/moodfetch
# - Otherwise, fall back to local repo path
if [ -d "/usr/local/share/moodfetch" ]; then
  script_dir="/usr/local/share/moodfetch"
else
  script_dir="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
fi

# Source our modules (quietly). Each module guards its own functions.
# These files are part of the project and expected to exist side-by-side.
# If any is missing, we bail with a friendly message.
for f in "utils.sh" "templates.sh" "metrics.sh" "mood_engine.sh"; do
  if [ ! -f "${script_dir}/${f}" ]; then
    echo "Missing dependency: ${f}. Please reinstall Moodfetch." >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  . "${script_dir}/${f}"
done

# --- MAIN ---
main() {
  # we keep it simple & friendly: clear, show logo, show heading, then the mood
  clear

  # print ascii logo if available; otherwise, no dramaâ€”just skip it
  if [ -f "${script_dir}/ascii-art.txt" ]; then
    cat "${script_dir}/ascii-art.txt"
  fi
  echo ""
  # Bold "Mood" header; if no ANSI, the raw text is still fine
  echo -e "\e[1mMood\e[0m"
  echo ""

  # 1) Collect system metrics (best-effort & portable)
  #    This fills a bunch of shell variables named: battery_pct, cpu_util_pct, etc.
  collect_all_metrics

  # 2) Ask the engine to pick the most relevant mood.
  #    The engine reads the exported variables from metrics + uses templates/placeholders.
  local final_mood
  final_mood="$(mood_engine_pick)"

  # 3) Print the chosen mood text
  echo "${final_mood}"
  echo ""
}
# ------

# Entry point
main "$@"
