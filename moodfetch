#!/usr/bin/env bash
# vim: noai:ts=4:sw=4:expandtab
# shellcheck source=/dev/null
# shellcheck disable=2009

# Resolve script directory:
# - For development, check if we're in a git repo and use src/ subdirectory  
# - If installed via `make install`, use /usr/local/share/moodfetch
# - Otherwise, fall back to local repo path with src/ subdirectory
repo_dir="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
if [ -d "${repo_dir}/.git" ] && [ -d "${repo_dir}/src" ]; then
  # We're in development mode - use src/ subdirectory
  script_dir="${repo_dir}/src"
elif [ -d "/usr/local/share/moodfetch/core" ]; then
  # Use installed version if it has the new structure
  script_dir="/usr/local/share/moodfetch"
else
  # Fallback to local src/ directory
  script_dir="${repo_dir}/src"
fi

# Source our modules (quietly). Each module guards its own functions.
# Core modules
for f in "utils.sh" "logging.sh" "signals.sh"; do
  module_path="${script_dir}/core/${f}"
  if [ ! -f "$module_path" ]; then
    echo "Missing core module: ${f}. Please reinstall Moodfetch." >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  . "$module_path"
done

# Configuration module
config_path="${script_dir}/config/config.sh"
# For development mode, config is in repo root
if [ -d "${repo_dir}/.git" ] && [ -f "${repo_dir}/config/config.sh" ]; then
  config_path="${repo_dir}/config/config.sh"
fi

if [ ! -f "${config_path}" ]; then
  echo "Missing configuration module. Please reinstall Moodfetch." >&2
  exit 1
fi
# shellcheck disable=SC1090
. "${config_path}"

# Metrics and mood modules
for f in "templates.sh" "metrics.sh" "mood_engine.sh" "os_detect.sh"; do
  module_path="${script_dir}/metrics/${f}"
  if [ ! -f "$module_path" ]; then
    echo "Missing metrics module: ${f}. Please reinstall Moodfetch." >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  . "$module_path"
done

# Initialize signal handlers early
init_signal_handlers

# Initialize configuration system
init_config

# Initialize OS detection now that all utilities are loaded
init_os_detect

# --- Update checking functions (only works in git repositories) ---
check_for_updates() {
    # Only check if we're in a git repository - graceful skip otherwise
    if [ ! -d ".git" ]; then
        log_debug "Not in a git repository, skipping update check"
        return 0
    fi
    
    # Get current local commit hash
    local local_commit
    if ! local_commit=$(git rev-parse HEAD 2>/dev/null) || [ -z "${local_commit}" ]; then
        log_debug "Could not determine local commit, skipping update check"
        return 0
    fi
    
    local remote_commit
    
    # Try git ls-remote first (faster and more reliable)
    if has_cmd git && remote_commit=$(timeout 1.5s git ls-remote origin main 2>/dev/null | cut -f1); then
        log_debug "Got remote commit via git ls-remote: ${remote_commit:0:8}"
    elif has_cmd curl; then
        # Use GitHub API as fallback
        local api_url="https://api.github.com/repos/kareemaboueid/moodfetch/commits/main"
        local api_response
        api_response=$(timeout 1.5s curl -s --max-time 1.5 "$api_url" 2>/dev/null)
        remote_commit=$(echo "$api_response" | grep -o '"sha": *"[^"]*"' | head -1 | cut -d'"' -f4)
        if [[ -n "$remote_commit" ]]; then
            log_debug "Got remote commit via GitHub API: ${remote_commit:0:8}"
        else
            log_debug "Could not parse GitHub API response"
            return 0
        fi
    else
        log_debug "Could not check for updates (network timeout or unavailable)"
        return 0
    fi
    
    # Compare commits
    if [ -n "${remote_commit}" ] && [ "${local_commit}" != "${remote_commit}" ]; then
        # Check if we're actually behind (not just different)
        if git merge-base --is-ancestor "${local_commit}" "${remote_commit}" 2>/dev/null; then
            show_update_notification
        else
            log_debug "Local commit differs but may not be behind remote"
        fi
    else
        log_debug "Repository is up-to-date"
    fi
}

# Show the update notification
show_update_notification() {
    echo ""
    echo "[!] A new update of moodfetch is available."
    echo "To update, run:"
    
    # Determine the current repository path
    local repo_path
    repo_path=$(pwd)
    
    # Check if globally installed to suggest appropriate update method
    if command -v moodfetch >/dev/null 2>&1 && [ "$(command -v moodfetch)" != "${repo_path}/moodfetch" ]; then
        echo "cd ${repo_path} && git pull && sudo make install"
    else
        echo "cd ${repo_path} && git pull"
    fi
}

# Initialize OS detection now that all utilities are loaded

# --- Parse flags (simple getopt-style) ---
# Parse command line arguments
for arg in "$@"; do
  case "$arg" in
    --debug)
      enable_debug
      shift
      ;;
    --help|-h)
      echo "Usage: moodfetch [options]"
      echo ""
      echo "Options:"
      echo "  --debug           Enable debug logging"
      echo "  --help, -h        Show this help and exit"
      echo ""
      echo "Tip: You can run 'bash -n *.sh' inside the repo to validate syntax quickly."
      exit 0
      ;;
  esac
done

# --- MAIN ---
main() {
  # Set defaults for undefined variables to prevent errors
  local no_color=${no_color:-false}
  
  # Bold "Mood" header; if no ANSI, the raw text is still fine
  if $no_color; then
    echo "Mood"
  else
    echo -e "\e[1mMood\e[0m"
  fi
  echo ""

  # Show temporary placeholder while processing
  printf "hmm..."

  # 1) Collect system metrics (best-effort & portable)
  collect_all_metrics

  # 2) Ask the engine to pick the most relevant mood.
  local final_mood
  final_mood="$(mood_engine_pick)"

  # Clear the placeholder and print the real mood
  # Use carriage return + ANSI clear line for clean output across terminals
  printf "\r\e[K%s\n" "${final_mood}"
  
  # Check for updates (only if in a git repository, non-blocking)
  check_for_updates
}

# ------
# Entry point
main "$@"
